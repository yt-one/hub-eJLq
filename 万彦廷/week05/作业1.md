## 核心功能

构建一个支持多级 FAQ 类目管理与智能问答匹配的系统。

## 后端方面

需设计数据库存储 FAQ 数据 以及 开发API对FAQ数据做CRUD。 

覆盖以下需求：

1. 多级类目

2. FAQ 主体 + 生效时间

3. 相似问法

4. 关联问题

5. 标签体系（多对多关系）

6. 答案视角（一问多答）

7. 答案类型（文本/富文本/卡片）


### 数据库设计
关系型数据库，表的形式大致如下:

1. 类目表：存储目录（支持树形结构）
```sql
CREATE TABLE categories (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    parent_id BIGINT NULL COMMENT 'NULL 表示一级类目',
    name VARCHAR(100) NOT NULL,
    sort_order INT DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE CASCADE,
    INDEX idx_parent (parent_id)
);
```

2. faqs 表存储 FAQ
```sql
CREATE TABLE faqs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    category_id BIGINT NOT NULL,
    standard_question VARCHAR(500) NOT NULL COMMENT '标准问法',
    effective_start DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    effective_end DATETIME NULL COMMENT 'NULL 表示永久生效',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    is_deleted TINYINT(1) DEFAULT 0,

    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE RESTRICT,
    INDEX idx_category (category_id),
);
```

3. 相似问法表 similar_questions
```sql
CREATE TABLE similar_questions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    faq_id BIGINT NOT NULL,
    question_text VARCHAR(500) NOT NULL,
    is_active TINYINT(1) DEFAULT 1,
    created_by VARCHAR(100) DEFAULT 'manual',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (faq_id) REFERENCES faqs(id) ON DELETE CASCADE,
    INDEX idx_faq_active (faq_id, is_active),
    UNIQUE uk_faq_question (faq_id, question_text) -- 防重复
);
```
4. 关联问题表
```sql
CREATE TABLE faq_relations (
    source_faq_id BIGINT NOT NULL COMMENT '触发问题',
    target_faq_id BIGINT NOT NULL COMMENT '关联问题',
    sort_order INT DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    PRIMARY KEY (source_faq_id, target_faq_id),
    FOREIGN KEY (source_faq_id) REFERENCES faqs(id) ON DELETE CASCADE,
    FOREIGN KEY (target_faq_id) REFERENCES faqs(id) ON DELETE CASCADE,
    CHECK (source_faq_id != target_faq_id) -- 禁止自关联
);
```

5. 标签表 tags + 多对多关联表 faq_tags
```sql
-- 标签定义（全局）
CREATE TABLE tags (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- FAQ 与标签关联
CREATE TABLE faq_tags (
    faq_id BIGINT NOT NULL,
    tag_id BIGINT NOT NULL,
    PRIMARY KEY (faq_id, tag_id),
    FOREIGN KEY (faq_id) REFERENCES faqs(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

```

6. 视角表 perspectives（预定义渠道视角）
```sql
CREATE TABLE perspectives (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL UNIQUE COMMENT '如: wechat, app, web',
    description VARCHAR(200),
    is_default TINYINT(1) DEFAULT 0 COMMENT '是否默认视角（兜底用）',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

7. 答案表 faq_answers（支持一问多视角多类型）
```sql
CREATE TABLE faq_answers (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    faq_id BIGINT NOT NULL,
    perspective_id BIGINT NOT NULL,
    answer_type ENUM('text', 'rich_text', 'card') NOT NULL,
    answer_content TEXT COMMENT 'text/rich_text 存内容；card 存描述',
    card_id BIGINT NULL COMMENT '仅当 answer_type=card 时有效，引用卡片工坊ID',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (faq_id) REFERENCES faqs(id) ON DELETE CASCADE,
    FOREIGN KEY (perspective_id) REFERENCES perspectives(id) ON DELETE RESTRICT,
    UNIQUE uk_faq_perspective (faq_id, perspective_id) -- 一个视角一个答案
);
```

### API设计

API设计围绕FAQ，以及其他需求大致覆盖以下功能：

| 功能 | 接口示例 |
|------|--------|
| FAQ CRUD | `POST /faqs`, `GET /faqs/{id}`, `PUT /faqs/{id}` |
| 相似问管理 | `POST /faqs/{id}/similar-questions` |
| 标签筛选 | `GET /faqs?tag=支付&category=101` |
| 按视角获取答案 | `GET /answer?question=...&perspective=wechat` |
| 获取关联推荐 | `GET /faqs/{id}/related` |

并提供类目的增删改查、FAQ 批量导入导出等 RESTful API。


### 与算法的集成

用户问题匹配过程：客户问题 -> 问题向量 -> 问题向量去查看和FAQ里问题的相似度 -> 返回最相似历史问题的faq_id

问题向量去查看和FAQ里问题的相似度用的是向量的相似度计算，所以需要用向量数据库存储 FAQ里问题的向量表示： 把问题的标准问法 和 其相似问题文本编码成向量后，存入向量数据库，绑定faq_id(FAQ表的主键值)


## 算法方面

算法核心目标是：将用户自然语言提问，精准匹配到知识库中最相关的标准问题，并返回对应答案。为此，我们采用以下技术方案：

1. 使用什么模型？ 选用 Sentence-BERT（SBERT）系列的预训练语义向量模型 作为基础匹配引擎。具体选择：
适配中文场景，比如 BAAI/bge-large-zh-v1.5。 BERT有变体能直接算两个文本的相似度分数，但有m个用户问题，n个历史记录，需要跑m*n次bert模型去对比
相似度，但是用SBERT把问题和历史记录都转成向量，再去算向量的相似度，只要跑m+n次bert模型，效率明显更高


2. 如何使用Bert？
- 离线阶段：
对每条 FAQ 的标准问法及其所有有效相似问法，分别用 SBERT 编码为向量；
将所有向量存入高效向量索引库，并绑定对应的 faq_id
- 在线阶段：
用户提问时，实时用同一 SBERT 模型将问题编码为向量；
在向量库中执行近似最近邻搜索（ANN），返回 Top-K 最相似的 faq_id；
后端根据 faq_id 查询数据库，返回对应视角下的答案。

3. 是否需要使用大模型？
在核心匹配环节，不需要大模型（如 Qwen、Chatgpt）。原因如下：
- SBERT 已能高效解决封闭域 FAQ 匹配问题，准确率高
- 大模型推理成本高、延迟大，不适合高频、低延迟的客服场景；
- 大模型存在幻觉风险，可能“编造”不存在的答案。
